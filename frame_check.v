///////////////////////////////////////////////////////////////////////////////
//   ____  ____ 
//  /   /\/   / 
// /___/  \  /    Vendor: Xilinx 
// \   \   \/     Version : 1.12
//  \   \         Application : Virtex-6 FPGA GTX Transceiver Wizard  
//  /   /         Filename : frame_check.v
// /___/   /\      
// \   \  /  \ 
//  \___\/\___\ 
//
//
// Module FRAME_CHECK
// Generated by Xilinx Virtex-6 FPGA GTX Transceiver Wizard
// 
// 
// (c) Copyright 2009-2011 Xilinx, Inc. All rights reserved.
// 
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
// 
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
// 
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
// 
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES. 


`timescale 1ns / 1ps
`define DLY #1

//***********************************Entity Declaration************************

module FRAME_CHECK #
(
    // parameter to set the number of words in the BRAM
    parameter   RX_DATA_WIDTH            =   16,
    parameter  RXCTRL_WIDTH              =    2
)	
(
    // User Interface
    input  wire [(RX_DATA_WIDTH-1):0] RX_DATA_IN,
    input  wire [(RXCTRL_WIDTH-1):0]  RXCTRL_IN,
    output wire [15:0]ErrorCount,
	output wire [15:0]  tx_data_r3,
	output wire   tx_charisk,
 // System Interface
    input  wire         USER_CLK,
    input  wire         SYSTEM_RESET
 
);


//***************************Internal Register Declarations******************** 

    reg             reset_on_error_in_r;
    reg             system_reset_r;

    reg             begin_r;
 (*Debug = "true"*)  reg             data_error_detected_r;
    reg     [8:0]   error_count_r;
 (*Debug = "true"*)  reg             error_detected_r;
    reg     [9:0]   read_counter_i;    

    reg     [79:0] rom [0:511];    

    reg     [(RX_DATA_WIDTH-1):0] rx_data_r;
    reg     [(RX_DATA_WIDTH-1):0] rx_data_r_track;

	reg             start_of_packet_detected_r;    
	reg             track_data_r;
	reg             track_data_r2;
	reg             track_data_r3;
	reg     [79:0]  rx_data_ram_r;
 (*MARK_DEBUG = "True"*)    reg     [(RX_DATA_WIDTH-1):0] rx_data_r2;
 (*MARK_DEBUG = "True"*)    reg     [(RX_DATA_WIDTH-1):0] rx_data_r3;
    reg     [(RX_DATA_WIDTH-1):0] rx_data_r4;
    reg     [(RX_DATA_WIDTH-1):0] rx_data_r5;
    reg     [(RX_DATA_WIDTH-1):0] rx_data_r6;
    reg     [(RXCTRL_WIDTH-1):0]  rxctrl_r;
    reg     [(RXCTRL_WIDTH-1):0]  rxctrl_r2;
    reg     [(RXCTRL_WIDTH-1):0]  rxctrl_r3;

    reg             rx_chanbond_seq_r;
    reg             rx_chanbond_seq_r2;
    reg             rx_chanbond_seq_r3; 
 
 
  (*Debug = "true"*)   reg     [1:0]   sel;

//*********************************Wire Declarations***************************


    (*Debug = "true"*) wire            error_detected_c;


	
    assign tx_data_r3                   = rx_data_r3;
    assign tx_charisk                   = (|rxctrl_r3==1'b1)?1'b1:1'b0;
//*********************************Main Body of Code***************************

    //___________ synchronizing the async reset for ease of timing simulation ________
      always@(posedge USER_CLK)
       system_reset_r <= `DLY SYSTEM_RESET;  

    //______________________ Register RXDATA once to ease timing ______________   

    always @(posedge USER_CLK)
    begin
        rx_data_r  <= `DLY    RX_DATA_IN;
        rx_data_r2 <= `DLY    rx_data_r;
    end 

    always @(posedge USER_CLK)
    begin
        rxctrl_r  <= `DLY    RXCTRL_IN;
    end
    //______________________________ Capture incoming data ____________________    

    always @(posedge USER_CLK)
    begin
        if(system_reset_r)    rx_data_r3 <= 'h0;
        else
        begin
            if(sel == 2'b01)
            begin
                rx_data_r3   <=  `DLY    {rx_data_r[(RX_DATA_WIDTH/2 - 1):0],rx_data_r2[(RX_DATA_WIDTH-1):RX_DATA_WIDTH/2]};  
            end
        else rx_data_r3  <=  `DLY    rx_data_r2;
        end
    end

    always @(posedge USER_CLK)
    begin
        if(system_reset_r)  
        begin
            rxctrl_r2      <=  `DLY   'h0;
            rxctrl_r3      <=  `DLY   'h0;
        end
        else
        begin
            rxctrl_r2      <=  `DLY   rxctrl_r;
            rxctrl_r3      <=  `DLY   rxctrl_r2;
        end
    end
    assign rx_data_aligned = rx_data_r3;
    // In 2 Byte scenario, when align_comma_word=1, Comma can appear on any of the two bytes
    // The comma is moved to the lower byte so that error checking can start
    always @(posedge USER_CLK)
    begin
        if(reset_on_error_in_r || system_reset_r)    sel <= 2'b00;
        else if (begin_r && !rx_chanbond_seq_r)
        begin
            // if Comma appears on BYTE0 ..
            if((rx_data_r[(RX_DATA_WIDTH/2 - 1):0] == 8'hBC) && rxctrl_r[0])
                sel <= 2'b00;
            // if Comma appears on BYTE1 ..            
            else if((rx_data_r[(RX_DATA_WIDTH-1):RX_DATA_WIDTH/2] == 8'hBC) && rxctrl_r[1])
            begin
                sel <= 2'b01;
            end
        end      
    end

	
	
	//!!!!add by LG //
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Check Data ~~~~~~~~~~~~~~~~~~~~~~~~~~~//
    reg [15:0]TempError;
	
	reg [15:0]TempData1;
	reg [15:0]TempData2;
	always @ (posedge USER_CLK)
	if(system_reset_r)begin
			TempData1 <= 0;
			TempData2 <= 0;
			end 
    else if(rxctrl_r3) begin
			rx_data_r3 <= rx_data_r3;
			TempData1 <= TempData1;
			TempData2 <= TempData2;
			end 
		else begin
		    TempData1 <= rx_data_r3;
			TempData2 <= TempData1; 
			end
			

	
	always @ (posedge USER_CLK)
	if(system_reset_r)begin
	   TempError <= 0;
	end
	else if (rxctrl_r3)begin
			TempError <=  TempError;
	    end
		else if(TempData2 + 1'b1 == TempData1 || TempData1==0 ) begin
				   TempError <=  TempError;
			 end 
			 else begin 
			      TempError <= TempError +1'b1;
			 end      
    
	
	assign ErrorCount = TempError;
    
endmodule           

